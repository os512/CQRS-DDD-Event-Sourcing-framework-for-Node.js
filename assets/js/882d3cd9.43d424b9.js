"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8011],{3245:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7378);const r=function(e){var t=e.children,n=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:r},t)}},5433:(e,t,n)=>{n.d(t,{Z:()=>d});var a=n(2685),r=n(7378),i=n(362),l=n(6751),o=n(8944);const m="tabItem_WhCL";function s(e){var t,n,i,s=e.lazy,d=e.block,u=e.defaultValue,p=e.values,c=e.groupId,g=e.className,h=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),k=null!=p?p:h.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),N=(0,l.lx)(k,(function(e,t){return e.value===t.value}));if(N.length>0)throw new Error('Docusaurus error: Duplicate values "'+N.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var b=null===u?u:null!=(t=null!=u?u:null==(n=h.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(i=h[0])?void 0:i.props.value;if(null!==b&&!k.some((function(e){return e.value===b})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+b+'" but none of its children has the corresponding value. Available values are: '+k.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var f=(0,l.UB)(),v=f.tabGroupChoices,y=f.setTabGroupChoices,M=(0,r.useState)(b),C=M[0],x=M[1],w=[],A=(0,l.o5)().blockElementScrollPositionUntilNextRender;if(null!=c){var R=v[c];null!=R&&R!==C&&k.some((function(e){return e.value===R}))&&x(R)}var T=function(e){var t=e.currentTarget,n=w.indexOf(t),a=k[n].value;a!==C&&(A(t),x(a),null!=c&&y(c,a))},D=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a=w.indexOf(e.currentTarget)+1;n=w[a]||w[0];break;case"ArrowLeft":var r=w.indexOf(e.currentTarget)-1;n=w[r]||w[w.length-1]}null==(t=n)||t.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":d},g)},k.map((function(e){var t=e.value,n=e.label,i=e.attributes;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:function(e){return w.push(e)},onKeyDown:D,onFocus:T,onClick:T},i,{className:(0,o.Z)("tabs__item",m,null==i?void 0:i.className,{"tabs__item--active":C===t})}),null!=n?n:t)}))),s?(0,r.cloneElement)(h.filter((function(e){return e.props.value===C}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},h.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==C})}))))}function d(e){var t=(0,i.Z)();return r.createElement(s,(0,a.Z)({key:String(t)},e))}},126:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>s,contentTitle:()=>d,metadata:()=>u,toc:()=>p,default:()=>g});var a=n(2685),r=n(1244),i=(n(7378),n(5318)),l=n(5433),o=n(3245),m=["components"],s={id:"monitoring-adapter",title:"Monitoring Adapter",description:"This document describes the interface that a monitoring adapter should expose."},d=void 0,u={unversionedId:"api/monitoring/monitoring-adapter",id:"api/monitoring/monitoring-adapter",title:"Monitoring Adapter",description:"This document describes the interface that a monitoring adapter should expose.",source:"@site/../docs/api/monitoring/monitoring-adapter.md",sourceDirName:"api/monitoring",slug:"/api/monitoring/monitoring-adapter",permalink:"/resolve/docs/api/monitoring/monitoring-adapter",tags:[],version:"current",frontMatter:{id:"monitoring-adapter",title:"Monitoring Adapter",description:"This document describes the interface that a monitoring adapter should expose."},sidebar:"docs",previous:{title:"Monitoring Interface",permalink:"/resolve/docs/api/monitoring/"},next:{title:"Monitoring Metric",permalink:"/resolve/docs/api/monitoring/metric"}},p=[{value:"Monitoring Adapter API",id:"monitoring-adapter-api",children:[{value:"<code>error</code>",id:"error",children:[{value:"Arguments",id:"arguments",children:[],level:4}],level:3},{value:"<code>execution</code>",id:"execution",children:[{value:"Arguments",id:"arguments-1",children:[],level:4}],level:3},{value:"<code>duration</code>",id:"duration",children:[{value:"Arguments",id:"arguments-2",children:[],level:4}],level:3},{value:"<code>time</code>",id:"time",children:[{value:"Arguments",id:"arguments-3",children:[],level:4}],level:3},{value:"<code>timeEnd</code>",id:"timeend",children:[{value:"Arguments",id:"arguments-4",children:[],level:4}],level:3},{value:"<code>custom</code>",id:"custom",children:[{value:"Arguments",id:"arguments-5",children:[],level:4}],level:3},{value:"<code>publish</code>",id:"publish",children:[{value:"Arguments",id:"arguments-6",children:[],level:4},{value:"Result",id:"result",children:[],level:4}],level:3},{value:"<code>rate</code>",id:"rate",children:[{value:"Arguments",id:"arguments-7",children:[],level:4}],level:3},{value:"<code>group</code>",id:"group",children:[{value:"Arguments",id:"arguments-8",children:[],level:4},{value:"Result",id:"result-1",children:[],level:4}],level:3},{value:"<code>getMetrics</code>",id:"getmetrics",children:[{value:"Result",id:"result-2",children:[],level:4}],level:3},{value:"<code>clearMetrics</code>",id:"clearmetrics",children:[],level:3}],level:2},{value:"Custom Monitoring Adapter Example",id:"custom-monitoring-adapter-example",children:[],level:2}],c={toc:p};function g(e){var t=e.components,n=(0,r.Z)(e,m);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"monitoring-adapter-api"},"Monitoring Adapter API"),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"TypeScript Support")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"A monitoring adapter object has an associated TypeScript type:"),(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},"Type Name - ",(0,i.kt)("inlineCode",{parentName:"li"},"MonitoringAdapter")),(0,i.kt)("li",{parentName:"ul"},"Package - ",(0,i.kt)("inlineCode",{parentName:"li"},"@resolve-js/core"))))),(0,i.kt)("p",null,"A monitoring adapter implementation should expose the following interface:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Member Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#error"},(0,i.kt)("inlineCode",{parentName:"a"},"error"))),(0,i.kt)("td",{parentName:"tr",align:null},"Registers an occurred error.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#execution"},(0,i.kt)("inlineCode",{parentName:"a"},"execution"))),(0,i.kt)("td",{parentName:"tr",align:null},"Registers execution of an operation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#duration"},(0,i.kt)("inlineCode",{parentName:"a"},"duration"))),(0,i.kt)("td",{parentName:"tr",align:null},"Registers duration of an operation.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#time"},(0,i.kt)("inlineCode",{parentName:"a"},"time"))),(0,i.kt)("td",{parentName:"tr",align:null},"Starts execution time measurement.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#timeend"},(0,i.kt)("inlineCode",{parentName:"a"},"timeEnd"))),(0,i.kt)("td",{parentName:"tr",align:null},"Ends execution time measurement and registers the resulting duration.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#custom"},(0,i.kt)("inlineCode",{parentName:"a"},"custom"))),(0,i.kt)("td",{parentName:"tr",align:null},"Registers a custom metric.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#publish"},(0,i.kt)("inlineCode",{parentName:"a"},"publish"))),(0,i.kt)("td",{parentName:"tr",align:null},"Defined by an implementation, publishes the collected metrics to the intended destination.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#rate"},(0,i.kt)("inlineCode",{parentName:"a"},"rate"))),(0,i.kt)("td",{parentName:"tr",align:null},"Registers operation execution rate during the specified time interval in seconds.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#group"},(0,i.kt)("inlineCode",{parentName:"a"},"group"))),(0,i.kt)("td",{parentName:"tr",align:null},"Creates a monitoring group.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#getmetrics"},(0,i.kt)("inlineCode",{parentName:"a"},"getMetrics"))),(0,i.kt)("td",{parentName:"tr",align:null},"Gets a list of collected metrics.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"#clearmetrics"},(0,i.kt)("inlineCode",{parentName:"a"},"clearMetrics"))),(0,i.kt)("td",{parentName:"tr",align:null},"Clears the list of collected metrics.")))),(0,i.kt)("p",null,"All of the listed functions except for ",(0,i.kt)("inlineCode",{parentName:"p"},"publish")," have a default implementation in the base package."),(0,i.kt)("h3",{id:"error"},(0,i.kt)("inlineCode",{parentName:"h3"},"error")),(0,i.kt)("p",null,"Registers an occurred error. The default implementation increments the count of the ",(0,i.kt)("inlineCode",{parentName:"p"},'"Errors"')," metric."),(0,i.kt)("h4",{id:"arguments"},"Arguments"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Argument Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"error")),(0,i.kt)("td",{parentName:"tr",align:null},"An ",(0,i.kt)("inlineCode",{parentName:"td"},"error")," object."),(0,i.kt)("td",{parentName:"tr",align:null},"An error to add to monitoring metrics.")))),(0,i.kt)("h3",{id:"execution"},(0,i.kt)("inlineCode",{parentName:"h3"},"execution")),(0,i.kt)("p",null,"Registers an operation's execution. The default implementation increments the count of the ",(0,i.kt)("inlineCode",{parentName:"p"},'"Executions"')," metric. The ",(0,i.kt)("inlineCode",{parentName:"p"},"execution")," method can also be passed an optional ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," parameter. If this parameter is not ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", the function registers the error in metrics."),(0,i.kt)("h4",{id:"arguments-1"},"Arguments"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Argument Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"error?")),(0,i.kt)("td",{parentName:"tr",align:null},"An ",(0,i.kt)("inlineCode",{parentName:"td"},"error")," object or ",(0,i.kt)("inlineCode",{parentName:"td"},"null")),(0,i.kt)("td",{parentName:"tr",align:null},"An error to add to monitoring metrics.")))),(0,i.kt)("h3",{id:"duration"},(0,i.kt)("inlineCode",{parentName:"h3"},"duration")),(0,i.kt)("p",null,"Registers the duration of an operation. The default implementation adds the specified value in milliseconds to the ",(0,i.kt)("inlineCode",{parentName:"p"},'"Duration"')," metric."),(0,i.kt)("h4",{id:"arguments-2"},"Arguments"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Argument Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"label")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:null},"A text label to add to the 'Label' dimension.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"duration")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"number")),(0,i.kt)("td",{parentName:"tr",align:null},"An operation duration in milliseconds.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"count?")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"number")),(0,i.kt)("td",{parentName:"tr",align:null},"A number to add to the metric's count. Defaults to ",(0,i.kt)("inlineCode",{parentName:"td"},"1"),".")))),(0,i.kt)("h3",{id:"time"},(0,i.kt)("inlineCode",{parentName:"h3"},"time")),(0,i.kt)("p",null,"Starts a timer to measure execution time."),(0,i.kt)("h4",{id:"arguments-3"},"Arguments"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Argument Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"name")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:null},"The ID of the started timer.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"timestamp?")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"number")),(0,i.kt)("td",{parentName:"tr",align:null},"A moment in time from which to start counting. Defaults to ",(0,i.kt)("inlineCode",{parentName:"td"},"Date.now()"),".")))),(0,i.kt)("h3",{id:"timeend"},(0,i.kt)("inlineCode",{parentName:"h3"},"timeEnd")),(0,i.kt)("p",null,"Ends time measurement and registers the resulting duration. The default implementation adds the measured time value in milliseconds to the ",(0,i.kt)("inlineCode",{parentName:"p"},'"Duration"')," metric."),(0,i.kt)("h4",{id:"arguments-4"},"Arguments"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Argument Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"name")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:null},"The ID of the timer to stop.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"timestamp?")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"number")),(0,i.kt)("td",{parentName:"tr",align:null},"A moment in time at which to stop counting. Defaults to ",(0,i.kt)("inlineCode",{parentName:"td"},"Date.now()"),".")))),(0,i.kt)("h3",{id:"custom"},(0,i.kt)("inlineCode",{parentName:"h3"},"custom")),(0,i.kt)("p",null,"Registers the specified custom metric. If the metric object's ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," and/or ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," fields are not specified, the default implementation sets them to ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,i.kt)("h4",{id:"arguments-5"},"Arguments"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Argument Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"metricData")),(0,i.kt)("td",{parentName:"tr",align:null},"A ",(0,i.kt)("a",{parentName:"td",href:"/resolve/docs/api/monitoring/metric#custom-metric-object"},"custom metric object"),"."),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies a custom metric's data.")))),(0,i.kt)("h3",{id:"publish"},(0,i.kt)("inlineCode",{parentName:"h3"},"publish")),(0,i.kt)("p",null,"Defined by an implementation, publishes the collected metrics to the intended destination."),(0,i.kt)("h4",{id:"arguments-6"},"Arguments"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Argument Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"options?")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"object")),(0,i.kt)("td",{parentName:"tr",align:null},"Specifies additional options for the publish operation.")))),(0,i.kt)("h4",{id:"result"},"Result"),(0,i.kt)("p",null,"The returned value is a ",(0,i.kt)("inlineCode",{parentName:"p"},"promise")," that resolves when the monitoring information is successfully published."),(0,i.kt)("p",null,"The monitoring adapters shipped with reSolve implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"publish")," function as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Module Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"@resolve-js/monitoring-console")),(0,i.kt)("td",{parentName:"tr",align:null},"Prints metrics to the text console.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"@resolve-js/monitoring-aws-cloudwatch")),(0,i.kt)("td",{parentName:"tr",align:null},"Publishes metrics to AWS CloudWatch.")))),(0,i.kt)("h3",{id:"rate"},(0,i.kt)("inlineCode",{parentName:"h3"},"rate")),(0,i.kt)("p",null,"Registers operation execution rate during the specified time interval in seconds. The default implementation adds a value in times per N seconds to the specified metric."),(0,i.kt)("h4",{id:"arguments-7"},"Arguments"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Argument Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"metricName")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:null},"The name of the metric to add.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"count")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"number")),(0,i.kt)("td",{parentName:"tr",align:null},"A number to add to the metric's count.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"seconds?")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"number")),(0,i.kt)("td",{parentName:"tr",align:null},"The number of seconds for which to count the rate. Defaults to ",(0,i.kt)("inlineCode",{parentName:"td"},"1"),".")))),(0,i.kt)("h3",{id:"group"},(0,i.kt)("inlineCode",{parentName:"h3"},"group")),(0,i.kt)("p",null,"Creates a monitoring group and returns a monitoring adapter instance for this group."),(0,i.kt)("h4",{id:"arguments-8"},"Arguments"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Argument Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"config")),(0,i.kt)("td",{parentName:"tr",align:null},"A key-value pair ",(0,i.kt)("inlineCode",{parentName:"td"},"object"),"."),(0,i.kt)("td",{parentName:"tr",align:null},"A key-value pair that identifies the group.")))),(0,i.kt)("h4",{id:"result-1"},"Result"),(0,i.kt)("p",null,"A monitoring adapter instance that operates on the created group."),(0,i.kt)("h3",{id:"getmetrics"},(0,i.kt)("inlineCode",{parentName:"h3"},"getMetrics")),(0,i.kt)("p",null,"Gets a list of collected metrics."),(0,i.kt)("h4",{id:"result-2"},"Result"),(0,i.kt)("p",null,"The returned value is an array of ",(0,i.kt)("a",{parentName:"p",href:"/resolve/docs/api/monitoring/metric"},(0,i.kt)("inlineCode",{parentName:"a"},"metric"))," objects."),(0,i.kt)("h3",{id:"clearmetrics"},(0,i.kt)("inlineCode",{parentName:"h3"},"clearMetrics")),(0,i.kt)("p",null,"Clear the list of collected metrics."),(0,i.kt)("h2",{id:"custom-monitoring-adapter-example"},"Custom Monitoring Adapter Example"),(0,i.kt)("p",null,"The code below demonstrates how to implement a monitoring adapter that uses ",(0,i.kt)("a",{parentName:"p",href:"https://prometheus.io/"},"Prometheus")," to publish metrics."),(0,i.kt)("p",null,"The adapter implementation redefines the base adapter's ",(0,i.kt)("inlineCode",{parentName:"p"},"publish")," function and reuses the default implementation for other API functions."),(0,i.kt)("p",null,"Note that Prometheus pulls metrics from an application through HTTP API calls. The implementation of an API handler that answers these calls is included."),(0,i.kt)(l.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"adapter",label:"Adapter Implementation",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="/common/prometheus-monitoring"',title:'"/common/prometheus-monitoring"'},"import client from 'prom-client'\nimport createBaseMonitoring from '@resolve-js/monitoring-base'\n\nconst roundFloat = (number, exp = 2) =>\n  Math.round(number * 10 ** exp) / 10 ** exp\n\nconst getLabelByDimensions = (dimensions, metricName) => {\n  if (metricName.includes(' Duration')) {\n    return dimensions[dimensions.length - 1].value\n  }\n\n  if (metricName === 'Executions') {\n    return dimensions[0].value\n  }\n\n  if (metricName === 'ReadModelFeedingRate') {\n    return dimensions[1].value\n  }\n\n  return dimensions.map(({ name, value }) => `${name}=\"${value}\"`).join(', ')\n}\n\nlet counter = null\nlet histogramDuration = null\nlet histogramFeedingRate = null\n\nconst createMonitoringImplementation = (context, { baseMonitoring }) => {\n  const monitoring = {\n    group: (config) =>\n      createMonitoringImplementation(context, {\n        baseMonitoring: baseMonitoring.group(config),\n      }),\n    duration: baseMonitoring.duration.bind(baseMonitoring),\n    error: baseMonitoring.error.bind(baseMonitoring),\n    time: baseMonitoring.time.bind(baseMonitoring),\n    timeEnd: baseMonitoring.timeEnd.bind(baseMonitoring),\n    publish: async ({ source = 'resolveDispose' } = {}) => {\n      const metrics = (baseMonitoring.getMetrics() ?? {}).metrics ?? []\n      const Registry = client.Registry\n\n      const executionMetrics = {}\n      const durationMetrics = {}\n      const readModelsFeedingRate = {}\n      const otherMetrics = []\n\n      for (const metric of metrics) {\n        const { dimensions, values, counts, unit, metricName } = metric\n        if (metricName === 'Executions' && dimensions[0]?.name === 'Part') {\n          const part = dimensions[0].value\n          const register = new Registry()\n          let gateway = new client.Pushgateway(\n            'http://localhost:9091',\n            [],\n            register\n          )\n\n          if (executionMetrics[part] == null) {\n            executionMetrics[part] = 0\n          }\n\n          for (let i = 0; i < counts.length; i++) {\n            executionMetrics[part] += counts[i]\n          }\n\n          try {\n            if (counter == null) {\n              counter = new client.Counter({\n                name: 'resolve_command_execution_on_push',\n                help: 'Count of execute commands',\n                labelNames: ['name', 'value'],\n              })\n            }\n          } catch (error) {\n            console.log('ERROR MONITORING', error.message)\n          }\n\n          register.registerMetric(counter)\n\n          for (const dimension of dimensions) {\n            counter.inc(dimension, executionMetrics[part])\n          }\n          gateway.pushAdd({ jobName: 'resolve_pushgateway' })\n        } else if (\n          metricName === 'Duration' &&\n          dimensions[0]?.name === 'Part'\n        ) {\n          const part = dimensions[0].value\n\n          const register = new Registry()\n          let gateway = new client.Pushgateway(\n            'http://localhost:9091',\n            [],\n            register\n          )\n\n          if (durationMetrics[part] == null) {\n            durationMetrics[part] = {\n              sum: 0,\n              count: 0,\n              min: Infinity,\n              max: -Infinity,\n            }\n          }\n\n          for (let i = 0; i < values.length; i++) {\n            durationMetrics[part].sum += values[i] * counts[i]\n            durationMetrics[part].count += counts[i]\n            durationMetrics[part].min = Math.min(\n              durationMetrics[part].min,\n              values[i]\n            )\n            durationMetrics[part].max = Math.max(\n              durationMetrics[part].max,\n              values[i]\n            )\n          }\n\n          try {\n            if (histogramDuration == null) {\n              histogramDuration = new client.Histogram({\n                name: 'resolve_command_duration_on_push',\n                help: 'Duration of execute commands',\n                labelNames: ['name', 'value'],\n              })\n            }\n          } catch (error) {\n            console.log('ERROR DURATION', error.message)\n          }\n\n          register.registerMetric(histogramDuration)\n\n          for (const dimension of dimensions) {\n            histogramDuration.labels(dimension).observe(10)\n          }\n\n          gateway.pushAdd({ jobName: 'resolve_pushgateway' })\n        } else if (metricName === 'ReadModelFeedingRate') {\n          let data = readModelsFeedingRate[dimensions[1].value]\n\n          const register = new Registry()\n          let gateway = new client.Pushgateway(\n            'http://localhost:9091',\n            [],\n            register\n          )\n\n          if (data == null) {\n            data = {\n              sum: 0,\n              count: 0,\n              min: Infinity,\n              max: -Infinity,\n            }\n\n            readModelsFeedingRate[dimensions[1].value] = data\n          }\n\n          for (let i = 0; i < values.length; i++) {\n            data.sum += values[i] * counts[i]\n            data.count += counts[i]\n            data.min = Math.min(data.min, values[i])\n            data.max = Math.max(data.max, values[i])\n          }\n\n          if ((histogramFeedingRate = null)) {\n            histogramFeedingRate = new client.Histogram({\n              name: 'resolve_command_feeding_rate_on_push',\n              help: 'Feeding rate of execute commands',\n              labelNames: ['name', 'value'],\n            })\n          }\n\n          register.registerMetric(histogramFeedingRate)\n\n          for (const dimension of dimensions) {\n            histogramFeedingRate.labels(dimension).observe(0.05)\n          }\n\n          gateway.pushAdd({ jobName: 'resolve_pushgateway' })\n        } else {\n          otherMetrics.push(metric)\n        }\n      }\n\n      const executionsRows = Object.keys(executionMetrics).map((part) => ({\n        name: `${part} executions`,\n        count: executionMetrics[part],\n      }))\n\n      const durationRows = Object.keys(durationMetrics).map((part) => ({\n        name: `${part} duration`,\n        average: roundFloat(\n          durationMetrics[part].sum / durationMetrics[part].count\n        ),\n        min: durationMetrics[part].min,\n        max: durationMetrics[part].max,\n        count: durationMetrics[part].count,\n      }))\n\n      const readModelsFeedingRateRows = Object.keys(readModelsFeedingRate).map(\n        (readModel) => ({\n          name: `\"${readModel}\" read model`,\n          average: roundFloat(\n            readModelsFeedingRate[readModel].sum /\n              readModelsFeedingRate[readModel].count\n          ),\n          min: roundFloat(readModelsFeedingRate[readModel].min),\n          max: roundFloat(readModelsFeedingRate[readModel].max),\n          count: roundFloat(readModelsFeedingRate[readModel].count),\n        })\n      )\n\n      const splittedMetrics = metrics.reduce(\n        (acc, { metricName, unit, dimensions, values, counts }) => {\n          if (metricName === 'Duration') {\n            metricName = `${dimensions[0].value} Duration`\n          }\n\n          let item = acc.find((i) => i.metricName === metricName)\n\n          if (item == null) {\n            item = {\n              metricName,\n              unit,\n              metrics: [],\n            }\n\n            acc.push(item)\n          }\n\n          const label = getLabelByDimensions(dimensions, metricName)\n          let itemMetric = item.metrics.find((i) => i.label === label)\n\n          if (itemMetric == null) {\n            item.metrics.push({\n              label,\n              values,\n              counts,\n            })\n          } else {\n            itemMetric.values.push(...values)\n            itemMetric.counts.push(...counts)\n          }\n\n          return acc\n        },\n        []\n      )\n\n      splittedMetrics.forEach((item) => {\n        const metricRows = item.metrics.map(({ label, values, counts }) => {\n          let sum = 0\n          let count = 0\n          let min = Infinity\n          let max = -Infinity\n\n          for (let i = 0; i < values.length; i++) {\n            sum += values[i] * counts[i]\n            count += counts[i]\n            min = Math.min(min, values[i])\n            max = Math.max(max, values[i])\n          }\n\n          if (item.unit === 'Count') {\n            return {\n              label,\n              count,\n            }\n          }\n\n          return {\n            label,\n            avg: parseFloat((sum / count).toFixed(2)),\n            min: parseFloat(min.toFixed(2)),\n            max: parseFloat(max.toFixed(2)),\n            count,\n          }\n        })\n      })\n      baseMonitoring.clearMetrics()\n    },\n    execution: baseMonitoring.execution.bind(baseMonitoring),\n    rate: baseMonitoring.rate.bind(baseMonitoring),\n    getMetrics: baseMonitoring.getMetrics.bind(baseMonitoring),\n    clearMetrics: baseMonitoring.clearMetrics.bind(baseMonitoring),\n  }\n\n  return monitoring\n}\n\nconst createMonitoring = () => {\n  const baseMonitoring = createBaseMonitoring()\n\n  return createMonitoringImplementation({ baseMonitoring }, { baseMonitoring })\n}\n\nexport default createMonitoring\n"))),(0,i.kt)(o.Z,{value:"handler",label:"Prometheus API Handler",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="/common/api-handlers/prometheus-handler.js"',title:'"/common/api-handlers/prometheus-handler.js"'},"import client, { register } from 'prom-client'\n\nlet counter = null\nlet histogramDuration = null\nlet histogramRate = null\nlet histogramOtherMetrics = null\nconst prometheusHandler = async (req, res) => {\n  const {\n    resolve: { monitoring },\n  } = req\n\n  const metrics = monitoring.getMetrics('default')\n\n  let inc = 0\n\n  if (!metrics.metrics.length) {\n    console.log('metrics has null')\n  }\n\n  for (const metric of metrics.metrics) {\n    try {\n      const { metricName, dimensions, values, counts, unit } = metric\n\n      if (metricName === 'Executions') {\n        if (counter == null) {\n          counter = new client.Counter({\n            name: 'resolve_command_execution',\n            help: 'Count of execute commands',\n            labelNames: ['name', 'value'],\n          })\n        }\n\n        for (let i = 0; i < counts.length; i++) {\n          inc += counts[i]\n        }\n\n        for (const dimension of dimensions) {\n          counter.inc(dimension, inc)\n        }\n        inc = 0\n      } else if (metricName == 'Duration') {\n        if (histogramDuration == null) {\n          histogramDuration = new client.Histogram({\n            name: 'resolve_command_duration',\n            help: 'Duration of execute commands',\n            labelNames: ['name', 'value'],\n          })\n        }\n\n        for (const dimension of dimensions) {\n          histogramDuration.labels(dimension).observe(10)\n        }\n      } else if (metricName == 'ReadModelFeedingRate') {\n        if (histogramRate == null) {\n          histogramRate = new client.Histogram({\n            name: 'resolve_command_feeding_rate',\n            help: 'Feeding rate of execute commands',\n            labelNames: ['name', 'value'],\n          })\n        }\n        for (const dimension of dimensions) {\n          histogramRate.labels(dimension).observe(10)\n        }\n      } else {\n        if (histogramOtherMetrics == null) {\n          histogramOtherMetrics = new client.Histogram({\n            name: 'resolve_command_other',\n            help: 'Other metrics',\n            labelNames: ['name', 'value'],\n          })\n        }\n        for (const dimension of dimensions) {\n          histogramRate.labels(dimension).observe(10)\n        }\n      }\n    } catch (error) {\n      console.log('ERROR prometheusHandler', error)\n    }\n  }\n  monitoring.clearMetrics('default')\n  res.text(await register.metrics())\n}\n\nexport default prometheusHandler\n"))),(0,i.kt)(o.Z,{value:"config",label:"Application Configuration",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="/config.app.js"',title:'"/config.app.js"'},"const appConfig = {\n  ...\n  monitoringAdapters: {\n    monitoringAdapter: {\n      module: '/common/prometheus-monitoring',\n    },\n  },\n  apiHandlers: [\n    {\n      handler: '/common/api-handlers/prometheus-handler.js',\n      path: '/metrics',\n      method: 'GET',\n    },\n    ...\n  ],\n  ...\n}\n")))))}g.isMDXComponent=!0},5318:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=a.createContext({}),s=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(m.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,m=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=s(n),c=r,g=p["".concat(m,".").concat(c)]||p[c]||u[c]||i;return n?a.createElement(g,l(l({ref:t},d),{},{components:n})):a.createElement(g,l({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=p;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);